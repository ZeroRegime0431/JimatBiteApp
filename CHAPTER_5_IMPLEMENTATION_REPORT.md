# Chapter 5: Implementation

## 5.1 Technical Issues

During the development of the JimatBite mobile application, several technical challenges were encountered that required careful investigation and resolution. One of the primary issues was **Firebase integration and authentication synchronization**. Initially, there was a disconnect between Firebase Authentication and Firestore database where user credentials were stored in both systems but not properly synchronized. This manifested when users who had accounts in Firestore could not authenticate through Firebase Auth, resulting in "invalid-credential" errors. The root cause was identified through systematic debugging of the authentication flow in the `services/auth.ts` file. The solution involved implementing a fallback mechanism that checks Firestore for valid credentials when Firebase Auth fails, and then recreates the authentication account if the Firestore record exists. This dual-check system ensured backward compatibility while maintaining security standards.

Another significant technical challenge involved **React Native and Expo Router navigation** complexities. The application uses Expo Router's file-based routing system (v6.0.17), which introduced several breaking changes from traditional React Navigation patterns. The team encountered issues with type safety and route parameters, particularly when passing complex objects between screens. TypeScript compilation errors frequently occurred due to incompatible type definitions between `expo-router` and `@react-navigation` packages. This was resolved by creating a comprehensive `declarations.d.ts` file to extend module definitions and properly type route parameters. Additionally, the migration from React Navigation's stack navigator to Expo Router's layout system required restructuring the entire `app/` directory and refactoring navigation logic across 40+ screen components. The solution involved creating a centralized `_layout.tsx` file that manages the root navigation structure and properly handles authentication state before rendering routes.

**Platform-specific compatibility issues** also presented substantial challenges, particularly with the implementation of push notifications. The Expo Notifications module required different configurations for Android and iOS platforms. On Android, setting up Firebase Cloud Messaging (FCM) required proper configuration of the `google-services.json` file, notification channels, and specific Android permissions (`RECEIVE_BOOT_COMPLETED`, `VIBRATE`, `WAKE_LOCK`) declared in `app.json`. The notification channel configuration in `services/notifications.ts` had to be carefully implemented to ensure maximum priority notifications with proper vibration patterns. A critical issue was discovered where the Expo Push Token could not be generated without a valid EAS project ID, which was resolved by properly configuring the `extra.eas.projectId` in the `app.json` configuration file. Furthermore, state management across the application presented challenges with data persistence and real-time updates. The cart system required synchronization between local AsyncStorage and Firestore to ensure data consistency. A race condition bug was identified in `cart-sidebar.tsx` where rapid updates to cart quantities could result in inconsistent state. This was resolved by implementing proper async/await patterns and debouncing user interactions to prevent concurrent Firestore write operations.

## 5.2 Challenges in Implementation

The implementation phase of JimatBite presented numerous practical challenges beyond technical issues. The most significant challenge was the **steep learning curve associated with the technology stack**. The development team had to simultaneously learn multiple new technologies including React Native, Expo, Firebase, TypeScript, and modern React patterns (React 19.1.0). React Native's paradigm shift from traditional web development—especially concepts like StyleSheet, platform-specific code, and mobile gestures—required substantial time investment. The team spent approximately 2-3 weeks in initial learning and experimentation before achieving productive development velocity. Firebase's extensive ecosystem (Authentication, Firestore, Cloud Storage, Cloud Messaging) also required deep understanding of each service's architecture, pricing model, security rules, and best practices. TypeScript integration added another layer of complexity, requiring the team to properly type all components, services, and data structures. The learning process was documented through extensive guides including `FIRESTORE_SETUP_GUIDE.md`, `NOTIFICATION_SETUP_GUIDE.md`, and `MERCHANT_SIGNUP_GUIDE.md`, which grew to over 500 lines of detailed documentation to help future developers onboard to the project.

**Project structure and architectural decisions** posed significant implementation challenges. Organizing over 40 screen components in the `app/` directory while maintaining clean separation of concerns required careful planning. The team had to establish conventions for organizing related functionality such as category pages (dessert, drink, meal, vegan, blindbox), order management screens (active, cancelled, completed), and merchant-specific screens. The decision to use a services layer (`services/auth.ts`, `services/database.ts`, `services/notifications.ts`) for business logic separation from UI components required substantial refactoring midway through development when it became clear that prop drilling and component-level data fetching were becoming unmaintainable. This refactoring involved extracting over 800 lines of database operations from component files into centralized service modules. Additionally, managing dual user flows—one for customers and one for merchants—required careful consideration of authentication state, role-based access control, and screen visibility logic. The implementation of merchant-specific features (menu item management, order processing) while maintaining the customer experience required extensive conditional rendering and navigation guards throughout the application.

**Time management and scope challenges** significantly impacted the implementation phase. The original project timeline underestimated the complexity of integrating multiple features such as real-time notifications, payment method management, cart persistence, favorites system, and QR code generation. Several feature implementations took 2-3 times longer than initially estimated, particularly the notification system which required understanding FCM setup, device token management, notification permissions across platforms, and backend integration. The development of comprehensive security through Firestore security rules was also more time-consuming than anticipated, requiring multiple iterations to properly implement user-specific data access controls. Resource constraints also affected implementation—Expo's free tier build limitations meant the team had to strategically time builds and use local development builds for most testing. The team also faced challenges with version compatibility as the project used cutting-edge versions (React 19.1.0, React Native 0.81.5, Expo 54) which occasionally had breaking changes or incomplete documentation. The implementation of `declarations.d.ts` for SVG imports and other type definitions was necessary to bridge gaps in third-party library type definitions. Despite these challenges, the team maintained progress through daily standups, comprehensive documentation, and incremental feature delivery, ensuring that core functionality was stable before adding advanced features.

## 5.3 Software Deployment

The deployment strategy for JimatBite was carefully planned to support both development testing and eventual production release. The application utilizes **Expo Application Services (EAS Build)** as the primary deployment platform, which was chosen after evaluating several alternatives including React Native CLI manual builds, AppCenter, and Bitrise CI/CD. EAS Build was selected for its seamless integration with the Expo ecosystem, simplified configuration through `eas.json`, and managed build infrastructure that eliminates the need for local Android Studio and Xcode setup. The deployment environment is cloud-based, leveraging Expo's build servers for compilation and Firebase services (Firestore Database, Authentication, Cloud Storage, Cloud Messaging) for backend infrastructure. This serverless architecture eliminates the need for maintaining dedicated backend servers, reducing infrastructure costs and operational complexity. The configuration in `eas.json` defines three distinct build profiles: **development** for building Expo Dev Client with hot reloading capabilities, **preview** for generating APK files for direct installation and testing on Android devices (and simulator builds for iOS), and **production** for creating optimized AAB (Android App Bundle) files suitable for Google Play Store submission.

The **deployment configuration and setup** process involved multiple critical steps documented in `BUILD_INSTRUCTIONS.md`. First, the team installed and configured the EAS CLI globally (`npm install -g eas-cli`) and authenticated with the Expo account. The `app.json` configuration file was meticulously configured with platform-specific settings including package identifiers (`com.jimatbite.app`), version codes, adaptive icons for Android with foreground, background, and monochrome variants, and notification permissions. The Firebase configuration required creating a Firebase project, enabling necessary services, and integrating credentials through `google-services.json` for Android. The `config/firebase.ts` file initializes Firebase services using the project's API keys and configuration parameters. For push notifications, FCM setup required enabling Cloud Messaging API in Google Cloud Console, configuring notification channels in the application code, and implementing device token registration through `services/notifications.ts`. The build process executes with commands like `eas build --platform android --profile preview`, which triggers a cloud build that typically completes in 10-20 minutes, producing downloadable APK files distributed through QR codes or direct download links that remain accessible for 30 days.

**Testing and deployment strategy** followed a phased approach to ensure application stability. During development, the team primarily used Expo Go and local development builds (`expo start`) for rapid iteration and testing, which allowed real-time code updates without rebuild cycles. Once core features were stable, the team transitioned to building APK files through the preview profile for wider testing on physical devices. Test users could install APK files directly by enabling "Install from Unknown Sources" in Android settings, allowing for beta testing without Play Store submission. The testing phase uncovered several deployment-specific issues including notification permission prompts not appearing correctly on Android 13+, splash screen rendering issues that required customizing `expo-splash-screen` plugin configuration with specific image widths and resize modes, and orientation locking that was resolved through the `app.json` orientation setting. Database setup required creating Firestore collections (`users`, `menuItems`, `orders`, `carts`, `paymentMethods`, `deviceTokens`) with appropriate indexes and security rules. The comprehensive `FIRESTORE_SETUP_GUIDE.md` provides step-by-step instructions with example documents and field structures to initialize the database properly. Post-deployment considerations include monitoring Firebase usage quotas (particularly Firestore read/write operations and Cloud Storage bandwidth), implementing analytics for user behavior tracking, and establishing a version management strategy for future updates. The production deployment profile is configured to generate AAB files optimized for Play Store submission, though actual store deployment is pending completion of Google Play Developer account setup and app store listing preparation. The current deployment status supports full testing and demonstration capabilities through direct APK distribution while maintaining the infrastructure for seamless production release when ready.
